// File: sumbits.v
// Generated by MyHDL 1.0dev
// Date: Thu Nov 26 14:50:32 2015


`timescale 1ns/10ps

module sumbits (
    Clk,
    D,
    Q
);
// a recursive pipelined implementation

input Clk;
input [16:0] D;
output [4:0] Q;
reg [4:0] Q;



reg  [3:0] lql;  
wire [8:0] dupper;  
reg  [3:0] lqu;  
wire [8:0] dlower;  
reg  [2:0] sbs1_lql;  
wire [4:0] sbs1_dupper;  
reg  [2:0] sbs1_lqu;  
wire [4:0] sbs1_dlower;  
reg  [1:0] sbs1_sbs1_lql;  
wire [2:0] sbs1_sbs1_dupper;  
reg  [1:0] sbs1_sbs1_lqu;  
wire [2:0] sbs1_sbs1_dlower;  
reg  [1:0] sbs1_sbs1_sbs1_lql;  
wire [1:0] sbs1_sbs1_sbs1_dupper;  
reg  [1:0] sbs1_sbs1_sbs1_lqu;  
wire [1:0] sbs1_sbs1_sbs1_dlower;  
reg  [1:0] sbs1_sbs1_sbs0_lql;  
wire [1:0] sbs1_sbs1_sbs0_dupper;  
reg  [1:0] sbs1_sbs1_sbs0_lqu;  
wire [1:0] sbs1_sbs1_sbs0_dlower;  
reg  [1:0] sbs1_sbs0_lql;  
wire [2:0] sbs1_sbs0_dupper;  
reg  [1:0] sbs1_sbs0_lqu;  
wire [2:0] sbs1_sbs0_dlower;  
reg  [1:0] sbs1_sbs0_sbs1_lql;  
wire [1:0] sbs1_sbs0_sbs1_dupper;  
reg  [1:0] sbs1_sbs0_sbs1_lqu;  
wire [1:0] sbs1_sbs0_sbs1_dlower;  
reg  [1:0] sbs1_sbs0_sbs0_lql;  
wire [1:0] sbs1_sbs0_sbs0_dupper;  
reg  [1:0] sbs1_sbs0_sbs0_lqu;  
wire [1:0] sbs1_sbs0_sbs0_dlower;  
reg  [2:0] sbs0_lql;  
wire [4:0] sbs0_dupper;  
reg  [2:0] sbs0_lqu;  
wire [4:0] sbs0_dlower;  
reg  [1:0] sbs0_sbs1_lql;  
wire [2:0] sbs0_sbs1_dupper;  
reg  [1:0] sbs0_sbs1_lqu;  
wire [2:0] sbs0_sbs1_dlower;  
reg  [1:0] sbs0_sbs1_sbs1_lql;  
wire [1:0] sbs0_sbs1_sbs1_dupper;  
reg  [1:0] sbs0_sbs1_sbs1_lqu;  
wire [1:0] sbs0_sbs1_sbs1_dlower;  
reg  [1:0] sbs0_sbs1_sbs0_lql;  
wire [1:0] sbs0_sbs1_sbs0_dupper;  
reg  [1:0] sbs0_sbs1_sbs0_lqu;  
wire [1:0] sbs0_sbs1_sbs0_dlower;  
reg  [1:0] sbs0_sbs0_lql;  
wire [2:0] sbs0_sbs0_dupper;  
reg  [1:0] sbs0_sbs0_lqu;  
wire [2:0] sbs0_sbs0_dlower;  
reg  [1:0] sbs0_sbs0_sbs1_lql;  
wire [1:0] sbs0_sbs0_sbs1_dupper;  
reg  [1:0] sbs0_sbs0_sbs1_lqu;  
wire [1:0] sbs0_sbs0_sbs1_dlower;  
reg  [1:0] sbs0_sbs0_sbs0_lql;  
wire [1:0] sbs0_sbs0_sbs0_dupper;  
reg  [1:0] sbs0_sbs0_sbs0_lqu;  
wire [1:0] sbs0_sbs0_sbs0_dlower;  




// the result is the sum of the two (terminal) leaves 
always @(posedge Clk) begin: sumbits_sbs0_sbs0_sbs0_sbs0_rtl2
    sbs0_sbs0_sbs0_lqu <= (sbs0_sbs0_sbs0_dupper[1] + sbs0_sbs0_sbs0_dupper[0]);
end

// the result is the sum of the two (terminal) leaves 
always @(posedge Clk) begin: sumbits_sbs0_sbs0_sbs0_sbs1_rtl2
    sbs0_sbs0_sbs0_lql <= (sbs0_sbs0_sbs0_dlower[1] + sbs0_sbs0_sbs0_dlower[0]);
end

// this will expand on the left in case the input data-size is uneven 

assign sbs0_sbs0_sbs0_dupper = sbs0_sbs0_dupper[3-1:2];
assign sbs0_sbs0_sbs0_dlower = sbs0_sbs0_dupper[2-1:0];

// the result is the sum of the previous branches 
always @(posedge Clk) begin: sumbits_sbs0_sbs0_sbs0_rtlr
    sbs0_sbs0_lqu <= (sbs0_sbs0_sbs0_lqu + sbs0_sbs0_sbs0_lql);
end

// the result is the sum of the two (terminal) leaves 
always @(posedge Clk) begin: sumbits_sbs0_sbs0_sbs1_sbs0_rtl2
    sbs0_sbs0_sbs1_lqu <= (sbs0_sbs0_sbs1_dupper[1] + sbs0_sbs0_sbs1_dupper[0]);
end

// the result is the sum of the two (terminal) leaves 
always @(posedge Clk) begin: sumbits_sbs0_sbs0_sbs1_sbs1_rtl2
    sbs0_sbs0_sbs1_lql <= (sbs0_sbs0_sbs1_dlower[1] + sbs0_sbs0_sbs1_dlower[0]);
end

// this will expand on the left in case the input data-size is uneven 

assign sbs0_sbs0_sbs1_dupper = sbs0_sbs0_dlower[3-1:2];
assign sbs0_sbs0_sbs1_dlower = sbs0_sbs0_dlower[2-1:0];

// the result is the sum of the previous branches 
always @(posedge Clk) begin: sumbits_sbs0_sbs0_sbs1_rtlr
    sbs0_sbs0_lql <= (sbs0_sbs0_sbs1_lqu + sbs0_sbs0_sbs1_lql);
end

// this will expand on the left in case the input data-size is uneven 

assign sbs0_sbs0_dupper = sbs0_dupper[5-1:3];
assign sbs0_sbs0_dlower = sbs0_dupper[3-1:0];

// the result is the sum of the previous branches 
always @(posedge Clk) begin: sumbits_sbs0_sbs0_rtlr
    sbs0_lqu <= (sbs0_sbs0_lqu + sbs0_sbs0_lql);
end

// the result is the sum of the two (terminal) leaves 
always @(posedge Clk) begin: sumbits_sbs0_sbs1_sbs0_sbs0_rtl2
    sbs0_sbs1_sbs0_lqu <= (sbs0_sbs1_sbs0_dupper[1] + sbs0_sbs1_sbs0_dupper[0]);
end

// the result is the sum of the two (terminal) leaves 
always @(posedge Clk) begin: sumbits_sbs0_sbs1_sbs0_sbs1_rtl2
    sbs0_sbs1_sbs0_lql <= (sbs0_sbs1_sbs0_dlower[1] + sbs0_sbs1_sbs0_dlower[0]);
end

// this will expand on the left in case the input data-size is uneven 

assign sbs0_sbs1_sbs0_dupper = sbs0_sbs1_dupper[3-1:2];
assign sbs0_sbs1_sbs0_dlower = sbs0_sbs1_dupper[2-1:0];

// the result is the sum of the previous branches 
always @(posedge Clk) begin: sumbits_sbs0_sbs1_sbs0_rtlr
    sbs0_sbs1_lqu <= (sbs0_sbs1_sbs0_lqu + sbs0_sbs1_sbs0_lql);
end

// the result is the sum of the two (terminal) leaves 
always @(posedge Clk) begin: sumbits_sbs0_sbs1_sbs1_sbs0_rtl2
    sbs0_sbs1_sbs1_lqu <= (sbs0_sbs1_sbs1_dupper[1] + sbs0_sbs1_sbs1_dupper[0]);
end

// the result is the sum of the two (terminal) leaves 
always @(posedge Clk) begin: sumbits_sbs0_sbs1_sbs1_sbs1_rtl2
    sbs0_sbs1_sbs1_lql <= (sbs0_sbs1_sbs1_dlower[1] + sbs0_sbs1_sbs1_dlower[0]);
end

// this will expand on the left in case the input data-size is uneven 

assign sbs0_sbs1_sbs1_dupper = sbs0_sbs1_dlower[3-1:2];
assign sbs0_sbs1_sbs1_dlower = sbs0_sbs1_dlower[2-1:0];

// the result is the sum of the previous branches 
always @(posedge Clk) begin: sumbits_sbs0_sbs1_sbs1_rtlr
    sbs0_sbs1_lql <= (sbs0_sbs1_sbs1_lqu + sbs0_sbs1_sbs1_lql);
end

// this will expand on the left in case the input data-size is uneven 

assign sbs0_sbs1_dupper = sbs0_dlower[5-1:3];
assign sbs0_sbs1_dlower = sbs0_dlower[3-1:0];

// the result is the sum of the previous branches 
always @(posedge Clk) begin: sumbits_sbs0_sbs1_rtlr
    sbs0_lql <= (sbs0_sbs1_lqu + sbs0_sbs1_lql);
end

// this will expand on the left in case the input data-size is uneven 

assign sbs0_dupper = dupper[9-1:5];
assign sbs0_dlower = dupper[5-1:0];

// the result is the sum of the previous branches 
always @(posedge Clk) begin: sumbits_sbs0_rtlr
    lqu <= (sbs0_lqu + sbs0_lql);
end

// the result is the sum of the two (terminal) leaves 
always @(posedge Clk) begin: sumbits_sbs1_sbs0_sbs0_sbs0_rtl2
    sbs1_sbs0_sbs0_lqu <= (sbs1_sbs0_sbs0_dupper[1] + sbs1_sbs0_sbs0_dupper[0]);
end

// the result is the sum of the two (terminal) leaves 
always @(posedge Clk) begin: sumbits_sbs1_sbs0_sbs0_sbs1_rtl2
    sbs1_sbs0_sbs0_lql <= (sbs1_sbs0_sbs0_dlower[1] + sbs1_sbs0_sbs0_dlower[0]);
end

// this will expand on the left in case the input data-size is uneven 

assign sbs1_sbs0_sbs0_dupper = sbs1_sbs0_dupper[3-1:2];
assign sbs1_sbs0_sbs0_dlower = sbs1_sbs0_dupper[2-1:0];

// the result is the sum of the previous branches 
always @(posedge Clk) begin: sumbits_sbs1_sbs0_sbs0_rtlr
    sbs1_sbs0_lqu <= (sbs1_sbs0_sbs0_lqu + sbs1_sbs0_sbs0_lql);
end

// the result is the sum of the two (terminal) leaves 
always @(posedge Clk) begin: sumbits_sbs1_sbs0_sbs1_sbs0_rtl2
    sbs1_sbs0_sbs1_lqu <= (sbs1_sbs0_sbs1_dupper[1] + sbs1_sbs0_sbs1_dupper[0]);
end

// the result is the sum of the two (terminal) leaves 
always @(posedge Clk) begin: sumbits_sbs1_sbs0_sbs1_sbs1_rtl2
    sbs1_sbs0_sbs1_lql <= (sbs1_sbs0_sbs1_dlower[1] + sbs1_sbs0_sbs1_dlower[0]);
end

// this will expand on the left in case the input data-size is uneven 

assign sbs1_sbs0_sbs1_dupper = sbs1_sbs0_dlower[3-1:2];
assign sbs1_sbs0_sbs1_dlower = sbs1_sbs0_dlower[2-1:0];

// the result is the sum of the previous branches 
always @(posedge Clk) begin: sumbits_sbs1_sbs0_sbs1_rtlr
    sbs1_sbs0_lql <= (sbs1_sbs0_sbs1_lqu + sbs1_sbs0_sbs1_lql);
end

// this will expand on the left in case the input data-size is uneven 

assign sbs1_sbs0_dupper = sbs1_dupper[5-1:3];
assign sbs1_sbs0_dlower = sbs1_dupper[3-1:0];

// the result is the sum of the previous branches 
always @(posedge Clk) begin: sumbits_sbs1_sbs0_rtlr
    sbs1_lqu <= (sbs1_sbs0_lqu + sbs1_sbs0_lql);
end

// the result is the sum of the two (terminal) leaves 
always @(posedge Clk) begin: sumbits_sbs1_sbs1_sbs0_sbs0_rtl2
    sbs1_sbs1_sbs0_lqu <= (sbs1_sbs1_sbs0_dupper[1] + sbs1_sbs1_sbs0_dupper[0]);
end

// the result is the sum of the two (terminal) leaves 
always @(posedge Clk) begin: sumbits_sbs1_sbs1_sbs0_sbs1_rtl2
    sbs1_sbs1_sbs0_lql <= (sbs1_sbs1_sbs0_dlower[1] + sbs1_sbs1_sbs0_dlower[0]);
end

// this will expand on the left in case the input data-size is uneven 

assign sbs1_sbs1_sbs0_dupper = sbs1_sbs1_dupper[3-1:2];
assign sbs1_sbs1_sbs0_dlower = sbs1_sbs1_dupper[2-1:0];

// the result is the sum of the previous branches 
always @(posedge Clk) begin: sumbits_sbs1_sbs1_sbs0_rtlr
    sbs1_sbs1_lqu <= (sbs1_sbs1_sbs0_lqu + sbs1_sbs1_sbs0_lql);
end

// the result is the sum of the two (terminal) leaves 
always @(posedge Clk) begin: sumbits_sbs1_sbs1_sbs1_sbs0_rtl2
    sbs1_sbs1_sbs1_lqu <= (sbs1_sbs1_sbs1_dupper[1] + sbs1_sbs1_sbs1_dupper[0]);
end

// the result is the sum of the two (terminal) leaves 
always @(posedge Clk) begin: sumbits_sbs1_sbs1_sbs1_sbs1_rtl2
    sbs1_sbs1_sbs1_lql <= (sbs1_sbs1_sbs1_dlower[1] + sbs1_sbs1_sbs1_dlower[0]);
end

// this will expand on the left in case the input data-size is uneven 

assign sbs1_sbs1_sbs1_dupper = sbs1_sbs1_dlower[3-1:2];
assign sbs1_sbs1_sbs1_dlower = sbs1_sbs1_dlower[2-1:0];

// the result is the sum of the previous branches 
always @(posedge Clk) begin: sumbits_sbs1_sbs1_sbs1_rtlr
    sbs1_sbs1_lql <= (sbs1_sbs1_sbs1_lqu + sbs1_sbs1_sbs1_lql);
end

// this will expand on the left in case the input data-size is uneven 

assign sbs1_sbs1_dupper = sbs1_dlower[5-1:3];
assign sbs1_sbs1_dlower = sbs1_dlower[3-1:0];

// the result is the sum of the previous branches 
always @(posedge Clk) begin: sumbits_sbs1_sbs1_rtlr
    sbs1_lql <= (sbs1_sbs1_lqu + sbs1_sbs1_lql);
end

// this will expand on the left in case the input data-size is uneven 

assign sbs1_dupper = dlower[9-1:5];
assign sbs1_dlower = dlower[5-1:0];

// the result is the sum of the previous branches 
always @(posedge Clk) begin: sumbits_sbs1_rtlr
    lql <= (sbs1_lqu + sbs1_lql);
end

// this will expand on the left in case the input data-size is uneven 

assign dupper = D[17-1:9];
assign dlower = D[9-1:0];

// the result is the sum of the previous branches 
always @(posedge Clk) begin: sumbits_rtlr
    Q <= (lqu + lql);
end

endmodule
